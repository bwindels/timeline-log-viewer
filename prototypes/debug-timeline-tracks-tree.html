<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				--scale: 1;
				font-family: sans-serif;
				font-size: 1rem;
				margin: 0;
			}
			
			main {
				--timescale-unit: 100;
				--timescale-line-start: calc(calc(calc(var(--timescale-unit) * var(--scale)) - 1) * 1px);
				--timescale-line-end: calc(calc(var(--timescale-unit) * var(--scale)) * 1px);
				overflow-x: scroll;
				/* seems to render a thicker line starting from scale 1.92 an no line at all from scale 2.56 */
				background: repeating-linear-gradient(to right,
					white 0px,
					white var(--timescale-line-start),
					gray var(--timescale-line-start),
					gray var(--timescale-line-end));
				background-attachment: local;
			}

			main, main div.subtree {
				/* use grid to have all item nodes overlap (instead of position: absolute),
				   so they can have an absolute offset from the left */
				display: grid;
			}

			div.subtree {
				margin-left: calc(1px * var(--scale) * var(--offset));
				grid-column: 1;
				grid-row: calc(1 + var(--row));
			}

			div.subtree.withChildren {
				/* hue could differ with type of node (e.g. network, storage, ...) */
				--hue: 120deg;
				/* when several layers of children start at same time as parent it is hard to see which parent they belong to, so try to indicated depth with increasingly darker color */
				background-color: hsl(var(--hue), 50%, calc(calc(1 - calc(calc(var(--depth) + 1) / 20)) * 100%));
			}

			main div.item {
				grid-column: 1;
				grid-row: 1;
				padding: 2px;
				margin-bottom: 2px;
				border: 1px solid black;
				color: black;
				overflow-x: hidden;
				box-sizing: border-box;
				overflow: hidden;
				white-space: nowrap;
				text-overflow: ellipsis;
				width: calc(1px * var(--scale) * var(--length));
				/* needs an explicit height because we don't want
				to get the height of the tallest sibling,
				as siblings might have children and be higher */
				height: 1.555rem;
				z-index: 1;
			}

			main div.subtree::before {
				content: "";
				grid-column: 1;
				grid-row: 1;
				--indicator-size: calc(0.2rem * var(--depth));
				/* 0.5 rem to always make the line visible, even if the child starts at the same time as parent */
				width: calc(calc(1px * var(--scale) * var(--offset)) + var(--indicator-size));
				border-bottom: 1px solid green;
				border-left: var(--indicator-size) solid green;
				height: 0.55rem;
				margin-top: 0.2rem;
				margin-left: calc(calc(-1px * var(--scale) * var(--offset)) - var(--indicator-size));
				z-index: 0;
			}

			main div.item:hover {
				min-width: max-content;
				z-index: 2;
			}

			.depth0 {
				background-color: lightgreen;
			}
			.depth1 {
				background-color: lightblue;
			}
			.depth2 {
				background-color: red;
			}
		</style>
	</head>
	<body>
		<!--
<div class="subtree" style="--offset: 5; --length: 100; --row: 1">
				<div class="item">sync</div>
				<div class="subtree" style="--offset: 5; --length: 200; --row: 1;">
					<div class="item" style="background-color: lightblue;">/sync</div>
					<div class="subtree" style="--offset: 50; --length: 100; --row: 1;">
						<div class="item" style="background-color: purple; color: white;">stuffs</div>
					</div>
				</div>
				<div class="subtree" style="--offset: 500; --length: 200; --row: 1;">
					<div class="item" style="background-color: lightblue;">persist</div>
				</div>
				<div class="subtree" style="--offset: 50; --length: 70; --row: 2;">
					<div class="item" style="background-color: lightblue;">/messages</div>
				</div>
			</div>
		-->
		<div>
			<div><input type="range" min="0.1" max="10" step="0.05" id="scale" value="1"><label for="scale">Scale</label></div>
		</div>
		<main>
			
		</main>
		<script type="text/javascript">
			document.getElementById("scale").addEventListener("input", event => {
				document.body.style.setProperty("--scale", event.target.value);
			});
			const data = [
				{values: {label: "sync", type: "root"}, start: 122, end: 2323, children: [
					{values: {label: "blub", type: "network"}, start: 60, end: 321},
					{values: {label: "/sync request", type: "network"}, start: 145, end: 235},
					{values: {label: "persist room", roomId: "!abc:matrix.org"}, start: 154, end: 210, children: [
						{values: {label: "write room summary", roomId: "!abc:matrix.org"}, start: 167, end: 371},
						{values: {label: "write timeline"}, start: 154, end: 321, children: [
							{values: {label: "new live fragment", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321}
							]},
						]},
					]},
					{values: {label: "persist room", roomId: "!sfsf:matrix.org"}, start: 178, end: 331},
					{values: {label: "persist room", roomId: "!fsdfsdf:matrix.org"}, start: 150, end: 321},
					{values: {label: "persist room", roomId: "!werew:matrix.org"}, start: 210, end: 321, children: [
						{values: {label: "write room summary", roomId: "!abc:matrix.org"}, start: 211, end: 255},
					]},
					{values: {label: "persist room", roomId: "!sdfdf:matrix.org"}, start: 1500, end: 2000},
				]}
			];

			// result is the return value of itemToNode, e.g. node and range
			function layoutChildren(childResults) {
				const rows = [];
				for(const result of childResults) {
					layoutChild(rows, result);
				}
				return rows;
			}

			function itemsOverlap(resultA, resultB) {
				const a = resultA.range;
				const b = resultB.range;

				if (a.start <= b.start) {
					return a.end > b.start;
				} else {
					return b.end > a.start;
				}
			}


			function layoutChild(rows, result) {
				for(const r of rows) {
					const overlapsWithRow = r.some(r => itemsOverlap(r, result));
					if (!overlapsWithRow) {
						r.push(result);
						// we found a row, exit early to avoid adding a row below
						return;
					}
				}
				rows.push([result]);
			}
			// returns the node and the total range (recursively) occupied by the node
			function itemToNode(item, parentOffset, depth) {
				const subtree = document.createElement("div");
				subtree.className = "subtree";
				const offset = item.start - parentOffset;
				subtree.style.setProperty("--offset", offset);
				subtree.style.setProperty("--length", item.end - item.start);
				subtree.style.setProperty("--depth", depth);
				const itemNode = document.createElement("div");
				// itemNode.className = `item depth${depth % 3}`;
				itemNode.className = `item depth0`;
				itemNode.appendChild(document.createTextNode(item.values.label));
				subtree.appendChild(itemNode);

				let minStart = item.start;
				let maxEnd = item.end;

				if (item.children) {
					subtree.classList.add("withChildren");
					let results = [];
					for (const c of item.children) {
						const result = itemToNode(c, parentOffset + offset, depth + 1);
						results.push(result);
						minStart = Math.min(minStart, result.range.start);
						maxEnd = Math.max(maxEnd, result.range.end);
					}
					const rows = layoutChildren(results);
					let row = 1;
					for (const r of rows) {
						for(const {node} of r) {
							node.style.setProperty("--row", row);
							subtree.appendChild(node);
						}
						row += 1;
					}
				}
				const range = {start: minStart, end: maxEnd};
				return {node: subtree, range};
			}

			const frag = document.createDocumentFragment();
			for (const ri of data) {
				frag.appendChild(itemToNode(ri, 0, 0).node);
			}
			document.querySelector("main").appendChild(frag);
		</script>
	</body>
</html>
