<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				--scale: 1;
				font-family: sans-serif;
				font-size: 1rem;
				margin: 0;
			}
			
			main {
				--timescale-unit: 100;
				--timescale-line-start: calc(calc(calc(var(--timescale-unit) * var(--scale)) - 1) * 1px);
				--timescale-line-end: calc(calc(var(--timescale-unit) * var(--scale)) * 1px);
				overflow-x: scroll;
				/* seems to render a thicker line starting from scale 1.92 an no line at all from scale 2.56 */
				background: repeating-linear-gradient(to right,
					white 0px,
					white var(--timescale-line-start),
					gray var(--timescale-line-start),
					gray var(--timescale-line-end));
				background-attachment: local;
			}

			main {
				--hue: 120deg;
			}

			main, main div.subtree {
				/* use grid to have all item nodes overlap (instead of position: absolute),
				   so they can have an absolute offset from the left */
				display: grid;
			}

			div.subtree {
				margin-left: calc(1px * var(--scale) * var(--offset));
				grid-column: 1;
				grid-row: calc(1 + var(--row));
				--brightness: calc(calc(1 - calc(var(--depth) / 20)) * 90%);
				--bg-color: hsl(var(--hue), 50%, var(--brightness));
				--border-color: hsl(var(--hue), 50%, calc(var(--brightness) - 30%));
			}

			main div.item.selected {
				--bg-color: Highlight;
				--border-color: Highlight;
				color: HighlightText;
			}

			main div.item {
				cursor: pointer;
				grid-column: 1;
				grid-row: 1;
				padding: 2px;
				margin-bottom: 2px;
				border: 1px solid var(--border-color);
				color: black;
				overflow-x: hidden;
				box-sizing: border-box;
				overflow: hidden;
				white-space: nowrap;
				text-overflow: ellipsis;
				width: calc(1px * var(--scale) * var(--length));
				min-width: 1rem;
				/* needs an explicit height because we don't want
				to get the height of the tallest sibling,
				as siblings might have children and be higher */
				height: 1.333em;
				z-index: 1;
				/* hue could differ with type of node (e.g. network, storage, ...) */
				/* when several layers of children start at same time as parent it is hard to see which parent they belong to, so try to indicated depth with increasingly darker color */
				background-color: var(--bg-color);
			}
			main div.dark {
				color: white;
			}

			main div.subtree::before {
				content: "";
				grid-column: 1;
				grid-row: 1;
				--indicator-size: calc(0.2rem * var(--depth));
				/* 0.5 rem to always make the line visible, even if the child starts at the same time as parent */
				width: calc(calc(1px * var(--scale)) * var(--offset));
				border-bottom: 1px solid var(--border-color);
				border-left: var(--indicator-size) solid var(--border-color);
				height: 0.55rem;
				margin-top: 0.2rem;
				margin-left: calc(calc(-1px * var(--scale) * var(--offset)) - var(--indicator-size));
				z-index: 0;
			}

			main div.item:hover, main div.item.selected {
				min-width: max-content;
				z-index: 2;
			}

			.type-info {
				--hue: 200deg;
			}

			.type-network {
				--hue: 0deg;
			}
		</style>
	</head>
	<body>
		<div>
			<div><input type="range" min="0.1" max="20" step="0.05" id="scale" value="1"><label for="scale">Scale</label></div>
		</div>
		<main>
			
		</main>
		<script type="text/javascript">
			/*
			idea: show chronogical (and if same in order) log in details panel of children, much like textual log?
			*/
			document.getElementById("scale").addEventListener("input", event => {
				const scale = parseFloat(event.target.value, 10);
				let timescaleUnit;
				if (scale >= 10) {
					timescaleUnit = 5;
				} else if (scale >= 5) {
					timescaleUnit = 10;
				} else if (scale >= 2) {
					timescaleUnit = 20;
				} else if (scale >= 1) {
					timescaleUnit = 500;
				} else if (scale >= 0.1) {
					timescaleUnit = 1000;
				}
				document.body.style.setProperty("--scale", scale);
				// document.querySelector("main").style.setProperty("--timescale-unit", timescaleUnit);
			});
			let selectedItemNode;
			document.querySelector("main").addEventListener("click", event => {
				if (selectedItemNode) {
					selectedItemNode.classList.remove("selected");
					selectedItemNode = null;
				}
				if (event.target.classList.contains("item")) {
					selectedItemNode = event.target;
					selectedItemNode.classList.add("selected");
				}
			});
			const data = [
				{values: {label: "sync", type: "root"}, start: 122, end: 2323, children: [
					{values: {label: "blub", type: "network"}, start: 60, end: 321, children: [
						{values: {label: "bar1", type: "info"}, start: 60, end: 60},
						{values: {label: "bar2", type: "info"}, start: 60, end: 60},
						{values: {label: "bar3", type: "info"}, start: 60, end: 60},
						{values: {label: "bar4", type: "info"}, start: 60, end: 60},
						{values: {label: "bar5", type: "info"}, start: 61, end: 61},
						{values: {label: "bar6", type: "info"}, start: 61, end: 61},
						{values: {label: "bar7", type: "info"}, start: 61, end: 61},
						{values: {label: "bar8", type: "info"}, start: 61, end: 61},
					]},
					{values: {label: "/sync request", type: "network"}, start: 145, end: 235},
					{values: {label: "persist room", roomId: "!abc:matrix.org"}, start: 154, end: 210, children: [
						{values: {label: "write room summary", roomId: "!abc:matrix.org"}, start: 167, end: 371},
						{values: {label: "write timeline"}, start: 154, end: 321, children: [
							{values: {label: "new live fragment", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", type: "info", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", type: "info", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", type: "info", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", type: "info", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", type: "info", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", type: "info", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321, children: [
								{values: {label: "foo", type: "info", oldLiveFragment: 4, newLiveFragment: 5}, start: 154, end: 321}
							]}
							]}
							]}
							]}
							]}
							]}
							]},
						]},
					]},
					{values: {label: "persist room", roomId: "!sfsf:matrix.org"}, start: 178, end: 331},
					{values: {label: "persist room", roomId: "!fsdfsdf:matrix.org"}, start: 150, end: 321},
					{values: {label: "persist room", roomId: "!werew:matrix.org"}, start: 210, end: 321, children: [
						{values: {label: "write room summary", roomId: "!abc:matrix.org"}, start: 211, end: 255},
					]},
					{values: {label: "persist room", roomId: "!sdfdf:matrix.org"}, start: 1500, end: 2000},
				]}
			];

			// result is the return value of itemToNode, e.g. node and range
			function layoutChildren(childResults) {
				const rows = [];
				for(const result of childResults) {
					layoutChild(rows, result);
				}
				return rows;
			}

			function itemsOverlap(resultA, resultB) {
				const a = resultA.range;
				const b = resultB.range;

				if (a.start <= b.start) {
					return a.end >= b.start;
				} else {
					return b.end >= a.start;
				}
			}


			function layoutChild(rows, result) {
				for(const r of rows) {
					const overlapsWithRow = r.some(r => itemsOverlap(r, result));
					if (!overlapsWithRow) {
						r.push(result);
						// we found a row, exit early to avoid adding a row below
						return;
					}
				}
				rows.push([result]);
			}
			// returns the node and the total range (recursively) occupied by the node
			function itemToNode(item, parentOffset, depth) {
				const subtree = document.createElement("div");
				subtree.className = "subtree";
				const offset = item.start - parentOffset;
				subtree.style.setProperty("--offset", offset);
				subtree.style.setProperty("--length", item.end - item.start);
				subtree.style.setProperty("--depth", depth);
				const itemNode = document.createElement("div");
				itemNode.className = "item";
				itemNode.appendChild(document.createTextNode(item.values.label));
				subtree.appendChild(itemNode);

				let minStart = item.start;
				let maxEnd = item.end;

				if (item.values && item.values.type) {
					subtree.classList.add(`type-${item.values.type}`);
				}

				if (depth > 8) {
					itemNode.classList.add("dark");
				}

				if (item.children) {
					subtree.classList.add("withChildren");
					let results = [];
					for (const c of item.children) {
						const result = itemToNode(c, parentOffset + offset, depth + 1);
						results.push(result);
						minStart = Math.min(minStart, result.range.start);
						maxEnd = Math.max(maxEnd, result.range.end);
					}
					const rows = layoutChildren(results);
					let row = 1;
					for (const r of rows) {
						for(const {node} of r) {
							node.style.setProperty("--row", row);
							subtree.appendChild(node);
						}
						row += 1;
					}
				}
				const range = {start: minStart, end: maxEnd};
				return {node: subtree, range};
			}

			const frag = document.createDocumentFragment();
			for (const ri of data) {
				frag.appendChild(itemToNode(ri, 0, 0).node);
			}
			document.querySelector("main").appendChild(frag);
		</script>
	</body>
</html>
